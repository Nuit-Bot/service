<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moderation</title>

    <style>
        select {
            width: 100%;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            color: whitesmoke;
            font-family: inherit;
            cursor: pointer;
            outline: none;
            transition: border-color 0.2s;
        }

        select:focus {
            border-color: #7171d3;
        }

        select option {
            background-color: #1d1d25;
            color: whitesmoke;
        }
    </style>
</head>

<body>
    <div id="moderation-container" data-server-id="__SERVER_ID__">
        <h1>Modération</h1>
        <label for="logChannel">Salons de logs</label>
        <select name="logChannel" id="logChannel">
            <option value="none">-- Pas de salon sélectionné --</option>
        </select>
    </div>

    <script>
        setTimeout(async () => {
            const serverId = document.getElementById('moderation-container').dataset.serverId;
            const logChannelSelect = document.getElementById('logChannel');

            try {
                // recuperer les canaux et la configuration en parallele
                const [channelsResponse, configResponse] = await Promise.all([
                    fetch(`/api/servers/${serverId}/channels`),
                    fetch(`/api/servers/${serverId}/config`)
                ]);

                if (!channelsResponse.ok) {
                    console.error('Failed to fetch channels');
                    return;
                }
                if (!configResponse.ok) {
                    console.error('Failed to fetch config');
                    return;
                }

                const channels = await channelsResponse.json();
                const config = await configResponse.json();

                // remplir le menu deroulant
                channels.forEach(channel => {
                    const option = document.createElement('option');
                    option.value = channel.id;
                    option.textContent = `#${channel.name}`;
                    logChannelSelect.appendChild(option);
                });

                // definir la valeur selectionnee en fonction de la configuration actuelle
                if (config.log_channel_id) {
                    logChannelSelect.value = config.log_channel_id;
                } else {
                    logChannelSelect.value = 'none';
                }

            } catch (error) {
                console.error('Error during data fetch:', error);
            }

            // ajouter un ecouteur d'evenement pour sauvegarder les modifications
            logChannelSelect.addEventListener('change', async (event) => {
                const channelId = event.target.value;
                if (!channelId) return;

                try {
                    const response = await fetch(`/api/config/edit?server_id=${serverId}&log_channel_id=${channelId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    if (response.ok) {
                        console.log('Log channel updated successfully.');
                        // fournir un retour utilisateur optionnel par exemple un petit message de succes
                    } else {
                        const errorData = await response.json();
                        console.error('Failed to update log channel:', errorData.error);
                        // fournir un retour utilisateur optionnel pour l'erreur
                    }
                } catch (error) {
                    console.error('Error updating log channel:', error);
                }
            });
        }, 50); // petit delai pour permettre au dom de se stabiliser
    </script>
</body>

</html>